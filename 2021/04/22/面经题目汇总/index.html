<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>面经题目汇总 | ZYJ&#39;s Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="面試常考題匯總本文主要汇总了常见面试题目，并按照知识点进行了分类。">
<meta property="og:type" content="article">
<meta property="og:title" content="面经题目汇总">
<meta property="og:url" content="http://example.com/2021/04/22/%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/index.html">
<meta property="og:site_name" content="ZYJ&#39;s Blog">
<meta property="og:description" content="面試常考題匯總本文主要汇总了常见面试题目，并按照知识点进行了分类。">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2021-04-22T06:31:06.000Z">
<meta property="article:modified_time" content="2021-04-22T06:38:54.789Z">
<meta property="article:author" content="Zhu Yongjian">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="ZYJ's Blog" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">ZYJ&#39;s Blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-面经题目汇总" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/04/22/%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/" class="article-date">
  <time class="dt-published" datetime="2021-04-22T06:31:06.000Z" itemprop="datePublished">2021-04-22</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      面经题目汇总
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="面試常考題匯總"><a href="#面試常考題匯總" class="headerlink" title="面試常考題匯總"></a>面試常考題匯總</h2><p>本文主要汇总了常见面试题目，并按照知识点进行了分类。</p>
<span id="more"></span>

<h3 id="1-多线程"><a href="#1-多线程" class="headerlink" title="1 多线程"></a>1 多线程</h3><h4 id="线程池有哪些参数"><a href="#线程池有哪些参数" class="headerlink" title="线程池有哪些参数"></a>线程池有哪些参数</h4><ul>
<li><strong>corePoolSize 线程池核心线程大小</strong></li>
</ul>
<p>线程池中会维护一个最小的线程数量，即使这些线程处理空闲状态，他们也不会被销毁，除非设置了allowCoreThreadTimeOut。这里的最小线程数量即是corePoolSize。</p>
<ul>
<li><strong>maximumPoolSize 线程池最大线程数量</strong></li>
</ul>
<p>一个任务被提交到线程池以后，首先会找有没有空闲存活线程，如果有则直接将任务交给这个空闲线程来执行，如果没有则会缓存到工作队列（后面会介绍）中，如果工作队列满了，才会创建一个新线程，然后从工作队列的头部取出一个任务交由新线程来处理，而将刚提交的任务放入工作队列尾部。线程池不会无限制的去创建新线程，它会有一个最大线程数量的限制，这个数量即由maximunPoolSize指定。</p>
<ul>
<li><strong>keepAliveTime 空闲线程存活时间</strong></li>
</ul>
<p>一个线程如果处于空闲状态，并且当前的线程数量大于corePoolSize，那么在指定时间后，这个空闲线程会被销毁，这里的指定时间由keepAliveTime来设定。</p>
<h4 id="sleep和wait的区别"><a href="#sleep和wait的区别" class="headerlink" title="sleep和wait的区别"></a>sleep和wait的区别</h4><p><strong>sleep</strong></p>
<ul>
<li>让当前线程休眠指定时间。</li>
<li>休眠时间的准确性依赖于系统时钟和CPU调度机制。</li>
<li>不释放已获取的锁资源，如果sleep方法在同步上下文中调用，那么其他线程是无法进入到当前同步块或者同步方法中的。</li>
<li>可通过调用interrupt()方法来唤醒休眠线程。</li>
</ul>
<p><strong>wait</strong></p>
<ul>
<li>让当前线程进入等待状态，当别的其他线程调用notify()或者notifyAll()方法时，当前线程进入就绪状态</li>
<li>wait方法必须在同步上下文中调用，例如：同步方法块或者同步方法中，这也就意味着如果你想要调用wait方法，前提是必须获取对象上的锁资源</li>
<li>当wait方法调用时，当前线程将会释放已获取的对象锁资源，并进入等待队列，其他线程就可以尝试获取对象上的锁资源。</li>
</ul>
<h4 id="Java有哪几种锁"><a href="#Java有哪几种锁" class="headerlink" title="Java有哪几种锁"></a>Java有哪几种锁</h4><ul>
<li>偏向锁/轻量级锁/重量级锁</li>
</ul>
<ul>
<li>可重入锁/不可重入锁</li>
<li>悲观锁/乐观锁</li>
<li>公平锁/非公平锁</li>
<li>可中断锁/不可中断锁</li>
<li>自旋锁/非自旋锁</li>
<li>独享锁/共享锁</li>
</ul>
<h4 id="进程、线程和协程有什么区别"><a href="#进程、线程和协程有什么区别" class="headerlink" title="进程、线程和协程有什么区别"></a>进程、线程和协程有什么区别</h4><ul>
<li><p><strong>进程</strong>，直观点说，保存在硬盘上的程序运行以后，会在内存空间里形成一个独立的内存体，这个内存体有自己独立的地址空间，有自己的堆，上级挂靠单位是操作系统。操作系统会以进程为单位，分配系统资源（CPU时间片、内存等资源），进程是资源分配的最小单位。</p>
</li>
<li><p><strong>线程</strong>，有时被称为轻量级进程(Lightweight Process，LWP），是操作系统调度（CPU调度）执行的最小单位。</p>
</li>
<li><p><strong>协程</strong>，是一种用户态的轻量级线程，协程的调度完全由用户控制。协程拥有自己的寄存器上下文和栈。协程调度切换时，将寄存器上下文和栈保存到其他地方，在切回来的时候，恢复先前保存的寄存器上下文和栈，直接操作栈则基本没有内核切换的开销，可以不加锁的访问全局变量，所以上下文的切换非常快。协程在子程序内部可中断的，然后转而执行别的子程序，在适当的时候再返回来接着执行。</p>
</li>
</ul>
<p><strong>两者联系：</strong></p>
<ul>
<li><p>一个线程只能属于一个进程，但一个进程可以有许多线程，最少有一个线程，一个线程也可以拥有很多协程。</p>
</li>
<li><p>当资源分配给一个进程，进程里的所有线程都可以共享资源。</p>
</li>
</ul>
<h4 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h4><ul>
<li><p><strong>管道：</strong>管道是一种半双工的通信方式，数据只能单向流动，而且只能在具有亲缘关系的进程间使用。进程的亲缘关系通常是指父子进程关系。</p>
</li>
<li><p><strong>有名管道：</strong>也是半双工通信，但是允许没有亲缘关系的进程间使用。</p>
</li>
<li><p><strong>信号：</strong>用于通知接收进程某个事件已经发生，主要作为进程间以及同一进程不同线程之间的同步手段。</p>
</li>
<li><p><strong>信号量：</strong>信号量是一个计数器，可以用来控制多个进程对共享资源的访问。它常作为一种锁机制，防止某进程正在访问共享资源时，其他进程也访问该资源。</p>
</li>
<li><p><strong>消息队列：</strong>消息队列是消息的双向链表，存放在内核中，用于共享数据存取。</p>
</li>
<li><p><strong>共享内存：</strong>指两个或多个进程共享一个给定的存储区，可以直接对内存存取，但需要同步。</p>
</li>
<li><p><strong>套接字：</strong>更为一般的进程间通信机制，与其他通信机制不同的是，它可用于不同机器间的进程通信。</p>
</li>
</ul>
<h4 id="什么是僵尸进程"><a href="#什么是僵尸进程" class="headerlink" title="什么是僵尸进程"></a>什么是僵尸进程</h4><p>僵尸进程是当子进程比父进程先结束，而父进程又没有回收子进程，释放子进程占用的资源，此时子进程将成为一个僵尸进程。</p>
<h3 id="2-Mysql"><a href="#2-Mysql" class="headerlink" title="2 Mysql"></a>2 Mysql</h3><h4 id="内连接和外连接"><a href="#内连接和外连接" class="headerlink" title="内连接和外连接"></a>内连接和外连接</h4><p><strong>内连接：</strong>指连接结果仅包含符合连接条件的行，参与连接的两个表都应该符合连接条件。</p>
<p><strong>外连接：</strong>连接结果不仅包含符合连接条件的行同时也包含自身不符合条件的行。包括左外连接、右外连接和全外连接。</p>
<ul>
<li><p><strong>左外连接：</strong>左边表数据行全部保留，右边表保留符合连接条件的行。</p>
</li>
<li><p><strong>右外连接：</strong>右边表数据行全部保留，左边表保留符合连接条件的行。</p>
</li>
<li><p><strong>全外连接：</strong>左外连接 union 右外连接。</p>
</li>
</ul>
<h4 id="Mysql数据库索引种类"><a href="#Mysql数据库索引种类" class="headerlink" title="Mysql数据库索引种类"></a>Mysql数据库索引种类</h4><p>*<strong>B-Tree索引</strong></p>
<ul>
<li>较为常用。</li>
<li>将索引放置于树中。</li>
<li>有利于范围查找。</li>
</ul>
<p>B-Tree通常意味着所有的值都是<strong>按顺序存储的</strong>，并且<strong>每个叶子页到根的距离相同</strong>。B-Tree索引能够加快访问数据的速度，因为存储引擎不再需要进行全表扫描来获取需要的数据，取而代之的是从索引的根节点开始进行搜索。根节点的槽中<strong>存放了指向子结点的指针</strong>，存储引擎根据这些指针向下层查找。通过比较节点页的值和要查找的值可以找到合适的指针进入下层子结点，这些指针实际上定义了子结点页中值的上限和下限。</p>
<p>*<strong>B+-Tree</strong></p>
<ul>
<li><p>非叶子节点不再存储数据，数据只存储在同一层的叶子节点上；B+树中根到每一个节点的路径长度一样，而B树不是这样。</p>
</li>
<li><p>叶子之间，增加了链表，获取所有节点，不再需要中序遍历；</p>
</li>
</ul>
<p>*<strong>Hash索引</strong></p>
<ul>
<li>创建了一个索引哈希表，记录了每个索引的哈希值已经数据存储地址。</li>
<li>哈希索引表里和原表顺序不同 例如查找id&lt;3的值，则效率慢。但是如果查找id=3，则效率很快。即范围查找慢，单值查找快。</li>
<li>较为不常用。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>哈希索引只包含哈希值和行指针，而<strong>不存储数据值</strong>，所以无法通过索引来避免读取行。（当select只取索引值时）</li>
<li>哈希表中的哈希值是有序的，但导致<strong>索引值是无序的</strong>，所以<strong>无法用于排序</strong></li>
<li>哈希索引不支持部分索引列匹配索引。因为<strong>哈希值是根据所有使用的索引列进行计算</strong>。所以当索引为(A,B)时，如果只使用A，索引无效。</li>
<li>哈希索引<strong>只支持等值查询，不支持范围查询。</strong></li>
<li>当出现哈希冲突时，需要遍历对应链表的所有行指针，逐行比较。</li>
<li>如果哈希冲突很多时，一些索引<strong>维护操作的代价也会很高</strong>。例如当做对应的删除操作时，需要遍历对应链表的所有行指针，找到并删除对应行的引用。</li>
</ul>
<h4 id="为什么B-比B树更适合做索引"><a href="#为什么B-比B树更适合做索引" class="headerlink" title="为什么B+比B树更适合做索引"></a>为什么B+比B树更适合做索引</h4><ul>
<li><p>范围查找，定位min与max之后，中间叶子节点，就是结果集，不用中序回溯；范围查询在SQL中用得很多，这是B+树比B树最大的优势。</p>
</li>
<li><p>叶子节点存储实际记录行，记录行相对比较紧密的存储，适合大数据量磁盘存储；非叶子节点存储记录的PK，用于查询加速，适合内存存储；</p>
</li>
<li><p>非叶子节点，不存储实际记录，而只存储记录的KEY的话，那么在相同内存的情况下，B+树能够存储更多索引；</p>
</li>
</ul>
<h4 id="为什么使用数据索引比较高效"><a href="#为什么使用数据索引比较高效" class="headerlink" title="为什么使用数据索引比较高效"></a>为什么使用数据索引比较高效</h4><ul>
<li>数据索引的存储是有序的。</li>
<li>在有序的情况下，通过索引查询一个数据是无需遍历索引记录的。</li>
<li>极端情况下，数据索引的查询效率为二分法查询效率，趋近于 log2(N)。</li>
</ul>
<h4 id="Mysql数据库三大范式"><a href="#Mysql数据库三大范式" class="headerlink" title="Mysql数据库三大范式"></a>Mysql数据库三大范式</h4><p><strong>第一范式(1NF)：</strong>每个列都不可以再拆分。<br><strong>第二范式(2NF)：</strong>在第一范式的基础上，非主键列完全依赖于主键，而不能是依赖于主键的一部分。<br><strong>第三范式(3NF)：</strong>在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键。</p>
<h4 id="Mysql事务的四大特性-ACID"><a href="#Mysql事务的四大特性-ACID" class="headerlink" title="Mysql事务的四大特性(ACID)"></a>Mysql事务的四大特性(ACID)</h4><ul>
<li><p><strong>原子性(Atomic)：</strong>原子性是指事务包含的所有操作要么全部成功，要么全部失败回滚，因此事务的操作如果成功就必须要完全应用到数据库，如果操作失败则不能对数据库有任何影响。</p>
</li>
<li><p><strong>一致性(Consistent)：</strong>事务执行前后的数据，必须保持一致。</p>
</li>
<li><p><strong>隔离性(Isolated)：</strong>隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。</p>
</li>
<li><p><strong>持久性(Durable)：</strong>持久性是指一个事务一旦被提交了，那么对数据库中的数据的改变就是永久性的，即便是在数据库系统遇到故障的情况下也不会丢失提交事务的操作。</p>
</li>
</ul>
<h4 id="Mysql隔离的四个级别"><a href="#Mysql隔离的四个级别" class="headerlink" title="Mysql隔离的四个级别"></a>Mysql隔离的四个级别</h4><table>
<thead>
<tr>
<th align="center">隔离级别</th>
<th align="center">脏读</th>
<th align="center">不可重复读</th>
<th align="center">幻读</th>
</tr>
</thead>
<tbody><tr>
<td align="center">未提交读</td>
<td align="center">可能</td>
<td align="center">可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">已提交读</td>
<td align="center">不可能</td>
<td align="center">可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">可重复读</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
<td align="center">可能</td>
</tr>
<tr>
<td align="center">可串行化</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
<td align="center">不可能</td>
</tr>
</tbody></table>
<h3 id="3-Redis"><a href="#3-Redis" class="headerlink" title="3 Redis"></a>3 Redis</h3><h4 id="Redis如何实现主从复制"><a href="#Redis如何实现主从复制" class="headerlink" title="Redis如何实现主从复制"></a>Redis如何实现主从复制</h4><p>分为大致三个阶段：<strong>连接建立阶段（即准备阶段）</strong>、<strong>数据同步阶段</strong>、<strong>命令传播阶段</strong></p>
<p><strong>连接建立阶段</strong></p>
<p>保存主节点信息—-建立socket链接—-发送ping命令—-身份验证—-发送从节点端口信息</p>
<p><strong>数据同步阶段</strong></p>
<p>主从节点之间的连接建立以后，便可以开始进行数据同步，该阶段可以理解为从节点数据的初始化。具体执行的方式是：从节点向主节点发送psync命令，开始同步。数据同步阶段是主从复制最核心的阶段，根据主从节点当前状态的不同，可以分为<strong>全量复制和部分复制</strong>。</p>
<p><strong>命令传播阶段</strong></p>
<p>数据同步阶段完成后，主从节点进入命令传播阶段；在这个阶段主节点将自己执行的写命令发送给从节点，从节点接收命令并执行，从而保证主从节点数据的一致性。</p>
<h4 id="Redis有哪几种数据类型"><a href="#Redis有哪几种数据类型" class="headerlink" title="Redis有哪几种数据类型"></a>Redis有哪几种数据类型</h4><ul>
<li>string（字符串）</li>
<li>hash（哈希）</li>
<li>list（列表）</li>
<li>set（集合）</li>
<li>zset(sorted set，有序集合)</li>
</ul>
<h4 id="Redis为什么用单线程"><a href="#Redis为什么用单线程" class="headerlink" title="Redis为什么用单线程"></a>Redis为什么用单线程</h4><p>因为CPU不是Redis的瓶颈。Redis的瓶颈最有可能是机器内存或者网络带宽。既然单线程容易实现，而且CPU不会成为瓶颈，那就顺理成章地采用单线程的方案了。缺点：服务器其他核闲置。</p>
<h4 id="为什么Redis读写速率快"><a href="#为什么Redis读写速率快" class="headerlink" title="为什么Redis读写速率快"></a>为什么Redis读写速率快</h4><ul>
<li><strong>Redis是纯内存数据库</strong>，相对于读写磁盘，读写内存的速度就不是几倍几十倍了，一般，hash查找可以达到每秒百万次的数量级。</li>
<li><strong>多路复用IO</strong>，“多路”指的是多个网络连接，“复用”指的是复用同一个线程。采用多路 I/O 复用技术可以让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）。可以直接理解为：单线程的原子操作，避免上下文切换的时间和性能消耗；加上对内存中数据的处理速度，很自然的提高redis的吞吐量。</li>
</ul>
<h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><p>缓存穿透是指缓存和数据库中都没有的数据，而用户不断发起请求，如发起为id为“-1”的数据或id为特别大不存在的数据。这时的用户很可能是攻击者，攻击会导致数据库压力过大。</p>
<h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><p>缓存击穿是指缓存中没有但数据库中有的数据（一般是缓存时间到期），这时由于并发用户特别多，同时读缓存没读到数据，又同时去数据库去取数据，引起数据库压力瞬间增大，造成过大压力</p>
<h4 id="缓存失效了该如何处理"><a href="#缓存失效了该如何处理" class="headerlink" title="缓存失效了该如何处理"></a>缓存失效了该如何处理</h4><p>缓存失效会导致数据库压力变大，一般没有好的解决办法，只能分析用户行为，均摊数据库压力。</p>
<h4 id="什么是缓存雪崩？要如何解决"><a href="#什么是缓存雪崩？要如何解决" class="headerlink" title="什么是缓存雪崩？要如何解决"></a>什么是缓存雪崩？要如何解决</h4><p>缓存雪崩是指缓存中数据大批量到过期时间而查询数据量巨大，引起数据库压力过大甚至宕机，也就是不同数据都过期了，很多数据都查不到从而查询数据库。</p>
<p><strong>解决：</strong>缓存数据的过期时间设置随机，防止同一时间大量数据过期现象发生。如果缓存数据库是分布式部署，将热点数据均匀分布在不同高的缓存数据库中。设置热点数据永不过期。</p>
<h3 id="4-算法-数据结构"><a href="#4-算法-数据结构" class="headerlink" title="4 算法/数据结构"></a>4 算法/数据结构</h3><h4 id="为什么HashMap的容量为2的n次方幂"><a href="#为什么HashMap的容量为2的n次方幂" class="headerlink" title="为什么HashMap的容量为2的n次方幂"></a>为什么HashMap的容量为2的n次方幂</h4><p>因为Hashmap计算存储位置时，使用了(n - 1) &amp; hash。只有当容量n为2的幂次方，n-1的二进制会全为1，位运算时可以充分散列，避免不必要的哈希冲突，所以扩容必须2倍就是为了维持容量始终为2的幂次方。</p>
<h4 id="各排序算法时间复杂度"><a href="#各排序算法时间复杂度" class="headerlink" title="各排序算法时间复杂度"></a>各排序算法时间复杂度</h4><p>选择排序：O(n^2)</p>
<p>Collection.Sort()：O(n*logn)</p>
<h4 id="流量控制算法"><a href="#流量控制算法" class="headerlink" title="流量控制算法"></a>流量控制算法</h4><ul>
<li><p><strong>漏桶：</strong>控制数据注入到网络的速率，平滑网络上的突发流量。漏桶算法提供了一种机制，通过它，突发流量可以被整形以便为网络提供一个稳定的流量。</p>
</li>
<li><p><strong>令牌桶：</strong>令牌桶可自行以恒定的速率源源不断地产生令牌。如果令牌不被消耗，或者被消耗的速度小于产生的速度，令牌就会不断地增多，直到把桶填满。后面再产生的令牌就会从桶中溢出。 　</p>
</li>
</ul>
<h4 id="哈希表和二叉树的区别"><a href="#哈希表和二叉树的区别" class="headerlink" title="哈希表和二叉树的区别"></a>哈希表和二叉树的区别</h4><ul>
<li>散列表中的数据是无序存储的，如果要输出有序的数据，需要先进行排序。而对于二叉查找树来说，我们只需要中序遍历，就可以在 O(n) 的时间复杂度内，输出有序的数据序列。</li>
</ul>
<ul>
<li>散列表扩容耗时很多，而且当遇到散列冲突时，性能不稳定，尽管二叉查找树的性能不稳定，但是在工程中，我们最常用的平衡二叉查找树的性能非常稳定，时间复杂度稳定在 O(logn)。</li>
</ul>
<ul>
<li>笼统地来说，尽管散列表的查找等操作的时间复杂度是常量级的，但因为哈希冲突的存在，这个常量不一定比 logn 小，所以实际的查找速度可能不一定比 O(logn) 快。加上哈希函数的耗时，也不一定就比平衡二叉查找树的效率高。</li>
</ul>
<ul>
<li>散列表的构造比二叉查找树要复杂，需要考虑的东西很多。比如散列函数的设计、冲突解决办法、扩容、缩容等。平衡二叉查找树只需要考虑平衡性这一个问题，而且这个问题的解决方案比较成熟、固定。</li>
</ul>
<ul>
<li>为了避免过多的散列冲突，散列表装载因子不能太大，特别是基于开放寻址法解决冲突的散列表，不然会浪费一定的存储空间。</li>
</ul>
<h4 id="什么是哈希冲突并如何解决"><a href="#什么是哈希冲突并如何解决" class="headerlink" title="什么是哈希冲突并如何解决"></a>什么是哈希冲突并如何解决</h4><p><strong>哈希冲突：</strong>把任意长度的输入，通过Hash算法变换成固定长度的输出，这个输出就是Hash值。哈希值的空间远小于输入的空间，所以可能会发生“哈希碰撞”，即两个不同的输入，产生了同一个输出。</p>
<p><strong>解决：</strong></p>
<p><strong>1.开放定址法</strong><br>当冲突发生时，形成某个探测序列；按此序列逐个探测散列表中的其他地址，直到找到给定的关键字或一个空地址(开放的地址)为止，将发生冲突的记录放到该地址中。</p>
<p><strong>2.线性探测法</strong><br>将散列表T[0 …m-1]看成循环向量。当发生冲突时，从初次发生冲突的位置依次向后探测其他的地址。</p>
<h3 id="5-计算机网络"><a href="#5-计算机网络" class="headerlink" title="5 计算机网络"></a>5 计算机网络</h3><h4 id="路由器和交换机有什么区别"><a href="#路由器和交换机有什么区别" class="headerlink" title="路由器和交换机有什么区别"></a>路由器和交换机有什么区别</h4><ul>
<li>工作层次不同，一个是<strong>网络层</strong>、一个是<strong>数据链路层</strong></li>
<li>寻址依据不同，一个是基于<strong>IP寻址</strong>，一个基于<strong>MAC寻址</strong></li>
<li>交换机分割冲突域，不划分广播域，即隶属一个交换机的主机属于一个局域网。通过路由器连接的主机可能数据不同的广播域，所以路由器可以划分广播域</li>
<li>转发的数据对象不同 ，交换机转发的是<strong>数据帧</strong>、路由器转发的是<strong>分组报文</strong></li>
</ul>
<h4 id="TCP-协议如何保证可靠传输"><a href="#TCP-协议如何保证可靠传输" class="headerlink" title="TCP 协议如何保证可靠传输"></a>TCP 协议如何保证可靠传输</h4><p>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</p>
<p><strong>校验和</strong>： TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</p>
<p>TCP 的接收端会丢弃重复的数据。</p>
<p><strong>流量控制</strong>： TCP 连接的每一方都有固定大小的缓冲空间，TCP的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</p>
<p><strong>拥塞控制</strong>： 当网络拥塞时，减少数据的发送。</p>
<p><strong>停止等待协议</strong>: 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就- 停止发送，等待对方确认。在收到确认后再发下一个分组。 超时重传： 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</p>
<p><strong>超时重传：</strong>发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到刚才发送数据的ACK确认报文（是通过确认序号的方式进行确认，即刚才发送数据的序列号+1），则对该报文进行重传。如果一直失败，满一定次数后就会放弃并发送一个复位信号。</p>
<h4 id="TCP-IP的七层模型和OSI的五层模型"><a href="#TCP-IP的七层模型和OSI的五层模型" class="headerlink" title="TCP/IP的七层模型和OSI的五层模型"></a>TCP/IP的七层模型和OSI的五层模型</h4><ul>
<li><strong>TCP/IP的七层模型：</strong>物理层，数据链路层，网络层，运输层，会话层，表现层，应用层。</li>
<li><strong>OSI的五层模型：</strong>物理层，数据链路层，网络层，运输层，应用层。</li>
</ul>
<h4 id="TCP、IP、HTTP分别在哪一层"><a href="#TCP、IP、HTTP分别在哪一层" class="headerlink" title="TCP、IP、HTTP分别在哪一层"></a>TCP、IP、HTTP分别在哪一层</h4><p>TCP在传输层，IP在网络层，HTTP在应用层</p>
<h4 id="TCP的拥塞控制是如何实现的"><a href="#TCP的拥塞控制是如何实现的" class="headerlink" title="TCP的拥塞控制是如何实现的"></a>TCP的拥塞控制是如何实现的</h4><p>TCP的拥塞控制包括<strong>慢启动</strong>、<strong>拥塞避免</strong>、<strong>快速重传</strong>、<strong>快速恢复</strong>。</p>
<ul>
<li><p><strong>慢启动：</strong>当一个<strong>新的TCP连接建立</strong>或者<strong>检测到由重传超时（RTO）导致丢包时</strong>，都会执行慢启动。整体过程大致为：当TCP初次发送数据时，并不是直接发送大量的数据，而是先发送一小部分数据，然后将数据量慢慢增加，直到达到一个阈值（ssthresh）之后，数据量不再增加，之后进入拥塞避免状态。</p>
</li>
<li><p><strong>拥塞避免：</strong>当达到慢启动达到阈值之后，cwnd就不再呈指数增长了，而是进入拥塞避免。在拥塞避免的算法下：TCP双方通信时，每经过一个往返时间RTT就将发送方的cwnd+1，使cwnd呈线性增长。当cwnd（拥塞窗口）一直增长，如果此时出现了丢包，那么就将ssthresh减半，将cwnd重新置1，下面又开始进入慢启动状态。</p>
</li>
<li><p><strong>快速重传：</strong>如果在TCP通信中出现了丢包，当发送端连续收到3个重复ACK之后，说明有数据包丢失。当有数据包丢失，不会启动慢启动，而是进入快速恢复。</p>
</li>
<li><p><strong>快速恢复：</strong>发送方将慢启动中的ssthresh值和cwnd值调整为当前窗口的一半，然后开始拥塞避免算法。</p>
</li>
</ul>
<h4 id="time-wait关键字的作用"><a href="#time-wait关键字的作用" class="headerlink" title="time_wait关键字的作用"></a><strong>time_wait关键字的作用</strong></h4><p>TCP在关闭的时候有个四次挥手的过程，主动关闭方在四次挥手的最后一个ACK发送之后会变成TIME_WAIT状态，经过 2MSL（MSL为报文最大生存时间） 这个时间，足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的。等待足够的时间以确保最后的 ACK 能让被动关闭方接收，从而帮助其正常关闭。</p>
<h4 id="大量出现time-wait怎么办"><a href="#大量出现time-wait怎么办" class="headerlink" title="大量出现time_wait怎么办"></a><strong>大量出现time_wait怎么办</strong></h4><p>解决TIME_WAIT大量出现，最核心的思想，就是打开系统的TIME_WAIT<strong>重用</strong>和<strong>快速回收</strong>。</p>
<h4 id="输入一个URL到返回响应过程"><a href="#输入一个URL到返回响应过程" class="headerlink" title="输入一个URL到返回响应过程"></a>输入一个URL到返回响应过程</h4><p>域名(DNS)解析——TCP三次握手建立连接——发起http请求——服务端接受请求并作出响应——浏览器收到响应并解析html代码——TCP四次挥手断开连接——浏览器渲染页面呈现给用户。</p>
<h4 id="TCP协议和UDP协议的区别"><a href="#TCP协议和UDP协议的区别" class="headerlink" title="TCP协议和UDP协议的区别"></a>TCP协议和UDP协议的区别</h4><table>
<thead>
<tr>
<th align="center"></th>
<th align="center">UDP</th>
<th align="center">TCP</th>
</tr>
</thead>
<tbody><tr>
<td align="center">是否连接</td>
<td align="center">无连接</td>
<td align="center">面向连接</td>
</tr>
<tr>
<td align="center">是否可靠</td>
<td align="center">不可靠，没有确认机制、流量控制和拥塞控制</td>
<td align="center">可靠，有确认机制、流量控制和拥塞控制</td>
</tr>
<tr>
<td align="center">连接对象个数</td>
<td align="center">支持一对一，一对多，多对一和多对多交互通信</td>
<td align="center">只支持一对一</td>
</tr>
<tr>
<td align="center">传输方式</td>
<td align="center">面向报文</td>
<td align="center">面向字节流</td>
</tr>
<tr>
<td align="center">首部开销</td>
<td align="center">首部开销小，固定8字节</td>
<td align="center">首部开销大，最小20字节，最大60字节</td>
</tr>
<tr>
<td align="center">使用场景</td>
<td align="center">适用于实时应用</td>
<td align="center">适用于要求可靠传输的应用，比如文件传输</td>
</tr>
</tbody></table>
<h4 id="TCP的三次握手"><a href="#TCP的三次握手" class="headerlink" title="TCP的三次握手"></a>TCP的三次握手</h4><ul>
<li>一开始，客户端和服务端都处于 <code>CLOSED</code> 状态。先是服务端主动监听某个端口，处于 <code>LISTEN</code> 状态。</li>
<li>客户端会随机初始化序号（<code>client_isn</code>），将此序号置于 TCP 首部的「序号」字段中，同时把 <code>SYN</code> 标志位置为 <code>1</code> ，表示 <code>SYN</code> 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 <code>SYN-SENT</code> 状态。</li>
<li>服务端收到客户端的 <code>SYN</code> 报文后，首先服务端也随机初始化自己的序号（<code>server_isn</code>），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 <code>client_isn + 1</code>, 接着把 <code>SYN</code> 和 <code>ACK</code> 标志位置为 <code>1</code>。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 <code>SYN-RCVD</code> 状态。</li>
<li>客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 <code>ACK</code> 标志位置为 <code>1</code> ，其次「确认应答号」字段填入 <code>server_isn + 1</code> ，最后把报文发送给服务端，这次报文可以携带客户到服务器的数据，之后客户端处于 <code>ESTABLISHED</code> 状态。</li>
<li>服务器收到客户端的应答报文后，也进入 <code>ESTABLISHED</code> 状态。</li>
</ul>
<h4 id="为什么TCP需要三次握手"><a href="#为什么TCP需要三次握手" class="headerlink" title="为什么TCP需要三次握手"></a>为什么TCP需要三次握手</h4><ul>
<li>三次握手才可以阻止历史重复连接的初始化（主要原因）</li>
<li>三次握手才可以同步双方的初始序列号</li>
<li>三次握手才可以避免资源浪费</li>
</ul>
<h4 id="TCP的四次挥手"><a href="#TCP的四次挥手" class="headerlink" title="TCP的四次挥手"></a>TCP的四次挥手</h4><ul>
<li>客户端打算关闭连接，此时会发送一个 TCP 首部 <code>FIN</code> 标志位被置为 <code>1</code> 的报文，也即 <code>FIN</code> 报文，之后客户端进入 <code>FIN_WAIT_1</code> 状态。</li>
<li>服务端收到该报文后，就向客户端发送 <code>ACK</code> 应答报文，接着服务端进入 <code>CLOSED_WAIT</code> 状态。</li>
<li>客户端收到服务端的 <code>ACK</code> 应答报文后，之后进入 <code>FIN_WAIT_2</code> 状态。</li>
<li>等待服务端处理完数据后，也向客户端发送 <code>FIN</code> 报文，之后服务端进入 <code>LAST_ACK</code> 状态。</li>
<li>客户端收到服务端的 <code>FIN</code> 报文后，回一个 <code>ACK</code> 应答报文，之后进入 <code>TIME_WAIT</code> 状态</li>
<li>服务器收到了 <code>ACK</code> 应答报文后，就进入了 <code>CLOSE</code> 状态，至此服务端已经完成连接的关闭。</li>
<li>客户端在经过 <code>2MSL</code> 一段时间后，自动进入 <code>CLOSE</code> 状态，至此客户端也完成连接的关闭。</li>
</ul>
<h4 id="socket编程的三种通信模型"><a href="#socket编程的三种通信模型" class="headerlink" title="socket编程的三种通信模型"></a>socket编程的三种通信模型</h4><p><strong>BIO：</strong>同步阻塞。一个连接一个线程。</p>
<p><strong>NIO：</strong>同步非阻塞。一个请求一个线程。</p>
<p><strong>AIO：</strong>异步非阻塞。一个有效请求一个线程。</p>
<p><strong>阻塞：</strong>应用程序在获取网络数据的时候，如果网络传输数据很慢，那么程序就一直等待，直到传输完毕为止。</p>
<p><strong>非阻塞：</strong>应用程序直接可以获取已经准备就绪的数据，无须等待。</p>
<h3 id="6-Java-Web"><a href="#6-Java-Web" class="headerlink" title="6 Java Web"></a>6 Java Web</h3><h4 id="session和cookie的区别"><a href="#session和cookie的区别" class="headerlink" title="session和cookie的区别"></a>session和cookie的区别</h4><ul>
<li>cookie 和session的区别是：cookie数据保存在客户端，session数据保存在服务器端；</li>
<li>两个都可以用来存私密的东西，同样也都有有效期的说法,区别在于session是放在服务器上的，过期与否取决于服务器的设定，cookie是存在客户端的，过期与否可以在cookie生成的时候设置进去；</li>
<li>cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗,如果主要考虑到安全应当使用session；</li>
<li>session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能，如果主要考虑到减轻服务器性能方面，应当使用COOKIE；</li>
<li>单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能3K。</li>
</ul>
<h4 id="Get和Post的区别"><a href="#Get和Post的区别" class="headerlink" title="Get和Post的区别"></a>Get和Post的区别</h4><ul>
<li>Get请求用来从服务器上获得资源，而Post是用来向服务器提交数据；</li>
<li>get将表单中数据按照name=value的形式，添加到action 所指向的URL 后面，并且两者使用”?”连接，而各个变量之间使用”&amp;”连接；post是将表单中的数据放在HTTP协议的请求头或消息体中，传递到action所指向URL；</li>
<li>get传输的数据要受到URL长度限制（1024字节）；而post可以传输大量的数据，上传文件通常要使用post方式；</li>
<li>使用get时参数会显示在地址栏上，如果这些数据不是敏感数据，那么可以使用get；对于敏感数据还是应用使用post；</li>
<li>get使用也叫百分号编码文本的格式传递参数，保证被传送的参数由遵循规范的文本组成。</li>
<li>get只能进行URL编码，post可以设置多种编码。 </li>
</ul>
<h4 id="削峰是如何实现的"><a href="#削峰是如何实现的" class="headerlink" title="削峰是如何实现的"></a>削峰是如何实现的</h4><p>用户的请求，服务器接收后，首先写入消息队列。假如消息队列长度超过最大数量，则直接抛弃用户请求或跳转到错误页面。秒杀业务根据消息队列中的请求信息，再做后续处理。</p>
<h4 id="MQ-消息队列-的应用场景"><a href="#MQ-消息队列-的应用场景" class="headerlink" title="MQ(消息队列)的应用场景"></a><strong>MQ(消息队列)的应用场景</strong></h4><p>异步、解耦、削峰。</p>
<p><strong>MQ的缺点：</strong>系统复杂性增加、系统可用性降低</p>
<h3 id="7-操作系统"><a href="#7-操作系统" class="headerlink" title="7 操作系统"></a>7 操作系统</h3><h4 id="什么是虚拟内存"><a href="#什么是虚拟内存" class="headerlink" title="什么是虚拟内存"></a>什么是虚拟内存</h4><p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续的可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。</p>
<h4 id="操作系统为什么要分用户态和系统态"><a href="#操作系统为什么要分用户态和系统态" class="headerlink" title="操作系统为什么要分用户态和系统态"></a>操作系统为什么要分用户态和系统态</h4><p>在计算机系统中区分系统态和用户态的原因是：避免代码进行潜在危险的操作，以防止给操作系统带来安全隐患。系统调用与返回的情况下进行两种方式的转换。用户态状态下，执行的代码被硬件限定，不能进行某些操作，比如写入其他进程的存储空间，以防止给操作系统带来安全隐患。内核禁止此状态下的代码进行潜在危险的操作，比如写入系统配置文件、杀掉其他用户的进程、重启系统等。当一个任务（进程）执行系统调用而陷入内核代码中执行时，我们就称进程处于内核运行态（或简称为内核态）。此时处理器处于特权级最高的（0 级）内核代码中执行。</p>
<h3 id="8-设计模式"><a href="#8-设计模式" class="headerlink" title="8 设计模式"></a>8 设计模式</h3><h4 id="懒汉模式、饿汉模式"><a href="#懒汉模式、饿汉模式" class="headerlink" title="懒汉模式、饿汉模式"></a>懒汉模式、饿汉模式</h4><ul>
<li><p><strong>懒汉模式：</strong>像一个懒汉一样，<strong>类加载时不创建实例</strong>，用户获取时才真正判断是否为空，如果为空才创建实例。</p>
</li>
<li><p><strong>饿汉模式：</strong>像一个饿汉一样，<strong>不管需不需要用到实例都要去创建实例</strong>，即在类产生的时候就创建好实例，这是一种空间换时间的做法。</p>
</li>
</ul>
<h4 id="单例模式为什么双重校验锁"><a href="#单例模式为什么双重校验锁" class="headerlink" title="单例模式为什么双重校验锁"></a>单例模式为什么双重校验锁</h4><p><strong>第一次校验：</strong>由于单例模式只需要创建一次实例，如果后面再次调用getUinqueSingle方法时，则直接返回之前创建的实例，因此大部分时间不需要执行同步方法里面的代码，大大提高了性能。如果不加第一次校验的话，那跟懒汉模式没什么区别，每次都要去竞争锁。<br><strong>第二次校验：</strong>如果没有第二次校验，假设线程t1执行了第一次校验后，判断为null，这时t2也获取了CPU执行权，也执行了第一次校验，判断也为null。接下来t2获得锁，创建实例。这时t1又获得CPU执行权，由于之前已经进行了第一次校验，结果为null（不会再次判断），获得锁后，直接创建实例。结果就会导致创建多个实例。所以需要在同步代码里面进行第二次校验，如果实例为空，则进行创建。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/04/22/%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/" data-id="cknsitwle0002nypo15zafue8" data-title="面经题目汇总" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2021/04/22/hello-world/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Hello World</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">April 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2021/04/22/%E9%9D%A2%E7%BB%8F%E9%A2%98%E7%9B%AE%E6%B1%87%E6%80%BB/">面经题目汇总</a>
          </li>
        
          <li>
            <a href="/2021/04/22/hello-world/">Hello World</a>
          </li>
        
          <li>
            <a href="/2021/04/22/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/">我的第一篇博客</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2021 Zhu Yongjian<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>